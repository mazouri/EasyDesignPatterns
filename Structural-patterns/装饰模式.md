装饰模式(包装模式)

动态的给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活

## 使用场景
- 需要透明且动态地扩展类的功能时。且在不影响其他对象的情况下
- 当不能采用继承对系统进行扩展时可以使用装饰模式。比如final类

## UML类图


## 简单实现
人穿衣服

## 源码中的实现
Context
Context类在Android中被称为“上帝对象”，它的本质就是一个抽象类，在装饰模式中相当于抽象组件，而在内部定义了大量的抽象方法，比如我们经常用到的startActivity方法。而真正实现是在ContextImpl中完成，那么ContextImpl 就是具体实现类。因为ContextWrapper 继承于Context ，所以ContextWrapper 就是装饰者。具体大家可以自行查看源码

## 实战


## 区别
1.与代理模式的区别

（1）装饰模式是以对客户端透明的方式扩展对象的功能，是继承方案的一个替代；而代理模式则是给一个对象提供一个代理对象，并有代理对象来控制对原有对象的引用。

（2）装饰模式应该为所装饰的对象增强功能；代理模式是对代理对象施加控制，不对对象本身功能进行增强。

2.与适配器模式的区别

适配器模式是用新接口来调用原接口，原接口对新系统是不可见的；装饰模式增强了其他对象的功能而同时又不改变它的接口。

## 优缺点
