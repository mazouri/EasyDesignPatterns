外观模式

要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。外观模式提供一个高层次的接口，使得子系统更易于使用

## 使用场景
- 为复杂子系统提供一个简单接口，对外隐藏子系统的具体实现、隔离变化
- 当你需要构建一个层次结构的子系统时，使用外观模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，你可以让它们仅通过外观接口进行通信，从而简化了它们之间的依赖关系

## UML类图


## 简单实例
手机集合了电话功能、短信功能、拍照和GPS等功能。那么以手机为例，简单的用外观模式实现一下

## 源码中的外观模式
Context


## 实战


## 优缺点

## 问题1：什么是外观模式？

解题思路：外观模式是通过一个外观类使得整个系统的接口只有一个统一的高层接口，这样可以降低调用者的使用成本，也对调用者屏蔽类很多实现细节。通常我们使用外观模式来封装API，比如一个项目的网络模块，图片加载模块等，而且很多第三方的SDK也通常会采用外观模式。

## 问题2：外观模式的UML

<img src="http://img.my.csdn.net/uploads/201212/04/1354636733_5965.jpg"/>

Facede是系统对外的统一接口，系统内部统一地工作。

SystemA、B、C是子系统。

外观模式就是通过一个统一的接口对外提供服务，使得外部程序只通过一个类就可以实现系统内部的多种功能。

## 问题3：举例

解题思路：友盟统计SDK就是使用的外观模式，在使用时我们基本上通过MobclickAgent这个类就可以完成我们所需要的功能，至于MobclickAgent的内部有其他的具体交互，我们可以不用关心,这个MobclickAgent就是一个外观类。

自己实现：

### Talk is cheap, show me your code!

```
写一个加载图片的外观类
public final class ImageLoader {

  public void displayImage(ImageView, Uri, listener) {
  
    //开启线程，网络请求图片，将结果设置给imageview，回调等
  }

}

```

ImageLoader对外暴露的方法只有displayImage方法，调用者只需传递ImageView和图片Uri就可以实现图片加载。至于图片的网络请求，图片的处理，最后把图片传递到UI线程并设置给ImageView等等这些操作，调用者都不用管，通过这个外观类就可以。这样使得图片的加载细节对调用者实现类隐藏，从而也减少了耦合。也使得图片加载这个功能系统极为好用。
