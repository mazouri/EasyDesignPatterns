# 单例模式

##使用场景
确保某个类有且只有一个对象的场景，避免产生多个对象消耗过多的资源，或者某个类型的对象只应该有且只有一个。
例如：创建一个对象需要消耗资源过多，如要访问IO和数据库等资源，这时就要考虑使用单例模式。

##单例模式的几种实现方式
###简单示例

###懒汉模式

###DCL实现单例

###静态内部类单例

###枚举单例

###使用容器实现单例

##源码中的单例模式
LayoutInflater
##单例模式的运用

##单例的优点

##单例的缺点


## 问题1：什么是单例模式？（单例模式的特点）

解题思路：单例模式是设计模式中应用最广的模式。单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个全局对象，这样有利于我们协调系统整体的行为。比如在一个应用中，应该只有一个ImageLoader实例，这个ImageLoader中又含有线程池、缓存系统、网络请求等，很消耗资源，因此，没有理由让它构造多个实例。像这种不能自由构造对象的情况，就需要使用单例模式。

>注：这个回答也是“单例模式的使用场景”的答案，可以将答案中的ImageLoader替换成自己项目中的单利类。比如访问IO、数据库SQLiteOpenHelper等。

## 问题2：单例模式的作用（目的）？

解题思路：单例模式的作用和目的就是保证在应用程序中，一个类只有一个实例存在。以避免产生多个对象（通常这个对象中包含耗资源的操作）消耗过多的资源。

## 问题3：一般单例模式有几种实现方式？哪一种更安全？

解题思路：参考博客：[单例模式的七种写法, 面试题：线程安全的单例模式](http://blog.csdn.net/liangxw1/article/details/51353654)

单例模式的实现方式一般有饿汉、懒汉、静态内部类、枚举、双重校验锁。考虑到多线程的话，懒汉模式通常又分为线程不安全懒汉模式和线程安全懒汉模式。

>几种实现方式的代码参见博客，需要熟练写出来。

对于饿汉模式，他是在声明静态对象时就已经初始化。饿汉模式在类加载到内存时就初始化了，因此是线程安全的。饿汉模式的缺点是它不是懒加载的。单例会在加载类后一开始就被初始化，即使我们没有去调用 getInstance()方法。一些场景下，比如类对象的实例化需要依赖一些参数，在getInstance() 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。

对于懒汉模式，它先声明一个静态对象，并且在第一次调用getInstance()方法时进行初始化。懒汉模式又分为线程不安全的和线程安全的。对于线程不安全的，它的getInstance()方法前没有synchronized修饰，那么当有多个线程并行的调用 getInstance()方法 的时候，就会创建多个实例。也就是说在多线程下不能正常工作。对于线程安全的，多了一个synchronized修饰，也就是将getInstance()方法设置为同步。但是线程安全的懒汉模式有个问题就是因为同步操作只需要在第一次调用时（也就是第一次创建单例实例对象时）才被需要，但是每次调用getInstance()方法的时候都会进行同步，这样就会消耗不必要的资源。这是懒汉单例模式存在的最大问题。因此懒汉模式一般不建议使用。

由于懒汉模式的缺点而引出了双重检验锁模式，也叫DCL单例模式。DCL单例模式是一种使用同步块加锁的方法。这种方式即可实现懒加载，又能保证线程安全，而且在单例对象初始化后调用getInstance()方法不进行同步锁。在DCL单例模式的getInstance()方法中，对instance进行了两次判空：第一层判断主要是为了避免不必要的同步，第二层的判断是为了在null的情况下创建实例。

>对于为什么这么写和sInstance需要volatile关键字修饰的原因？见《书》P26-27DCL实现单例。























