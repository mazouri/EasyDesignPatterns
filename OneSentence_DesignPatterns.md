
一、单例：确保某个类有且仅有一个对象。比如访问IO和数据库时可使用单例模式。

二、观察者：定义了对象之间的一种“一对多”的依赖关系；当一个对象的状态发生改变时，所有依赖于它的对象都将收到通知并自动改变。比如消息队列、事件总线等

三、MVC：Model-View-Controller,模型－视图－控制器。使用MVC可以实现界面的显示与业务逻辑，数据处理的解耦。
> 对于Android来说，View层采用xml文件进行界面的描述
> Model层：数据体，以及业务逻辑，比如：数据库操作，网络操作，复杂算法，耗时任务等
> Controller层：在Android中，Activity处理用户交互问题，因此可以认为Activity就是控制器，Activity获取数据以及界面元素，并将两者进行绑定。控制用户输入，并向Model发送数据请求。

> 框架是大智慧，用来对软件设计进行分工；
> 设计模式是小技巧，对具体问题提出解决方案，以提高代码复用率，降低耦合度。

MVP：Model-View-Presenter。
> MVP和MVC的区别在于，在MVP中View并不直接使用Model，它们之间的通信是通过Presenter来进行的，所有的交互都发生在Presenter内部；
> 而在MVC中View会从Model中读取数据，而不是通过Controller。

> 画出MVC和MVP的结构图

MVVM:Model-View-ViewModel。是MVP的升级版。主要用到了DataBinding库

四、工厂方法：定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类。
> 主要是为了创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。

五、抽象工厂：为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。

六、装饰：动态地给一个对象添加一些额外的职责。就增加功能来说。装饰模式相比生成子类更为灵活。

七、代理：为其他对象提供一种代理以控制对这个对象的访。
> 当无法或不想直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，委托对象与代理对象需要实现相同的接口

八、适配器：Adapter 适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配无法在一起工作的两个类可以在一起工作
> 在我们的开发中使用率极高，比如ListView、GridView以及RecyclerView都需要使用
> 分为对象适配器和类适配器

九、外观：要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。外观模式提供一个高层次的接口，使得子系统更易于使用

十、迭代器：提供一种方法顺序访问一个容器对象中的各个元素，而又不需要暴露该对象的内部表示
> 当遍历一个容器对象时，可以使用迭代器模式

十一、Builder：将一个复杂对象的构建与它的表示进行分离，使得同样的构建过程可以创建不同的表示。
> 当初始化一个对象特别复杂时，如参数多，且很多参数有默认值

十二、原型：用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。被复制的实例就是“原型”，这个原型是可定制的。

十三、六大原则：
- 1.单一指责：一个类中应该是一组相关性很高的函数、数据的封装
- 2.开闭：指对扩展开发，对修改封闭。当软件需要变化时，我们应该尽量通过扩展的方式来实现变化，而不是通过修改已有的代码来实现
- 3.里氏替换：只要父类能出现的地方，子类就可以出现，而且替换为子类也不会产生任何错误或异常
- 4.依赖倒置：高层次模块不依赖于低层次模块的实现细节
- 5.接口隔离：类间的依赖关系应该建立在最小的接口上。此原则，将非常庞大、臃肿的接口拆分成更小的和更具体的接口
- 6.迪米特：一个对象应该对其他对象有最少的了解。类的内部怎么实现与调用这或者依赖者没关系。

